INTRODUCTION TO GLSL
====================
glsl is a statically typed imperative programming language

variables must be assigned a type when declared
	3 scalar types:
	bool, int, float
operators
	+,-,*,/,<,>,<=,>=,==,!=
	+=,-=,*=,/=,++,--
procedures
	can decompose shaders into subroutines with C-like syntax
	declaration needs return type or "void" if none

QUALIFIERS AND BUILT-INS
========================

precision specifiers
	floats are declared with an optional precision specifier that tells the GPU how many bits to use
		lowp - lowest possible
		mediump - default precision
		highp - highest possible
	can specify precision of all floats with
		precision highp float; @ top

constants
	const

in/out
	functions return a single value but can simulate multiple returns with reference types
	type qualifiers for procedure arguments
		in - passes argument value (default behavior)
		inout - passes argument by reference
		out - argument uninitialized, but writing to the value updates the parameter
		const - constant value

built-ins
	built in functions some include
		radians, degrees
		sin, cos, tan, asin, acos, atan
		exp, log, exp2, log2
		pow, sqrt, inversesqrt
		floor, ceil, fract, mod, step
		abs, sign, min, max, clamp
		mix - interpolation

VECTORS
=======

built in types for vectors
	bvec2, bvec3, bvec4 - boolean vector
	ivec2, ivec3, ivec4 - integer vector
	vec2, vec3, vec4    - float vector

swizzles

for accessing components of vectors
	First component of p  = p.x = p.r = p.s = p[0]
	Second component of p = p.y = p.g = p.t = p[1]
	Third component of p  = p.z = p.b = p.u = p[2]
	Fourth component of p = p.w = p.a = p.v = p[3]

can select ranges/subtypes with same symbols i.e. p.xxy

arithmetic operations are applied component-wise

geometric functions
	length(p) - euclidian length
	distance(a,b) - euclidian distance
	dot(a,b) - dot product
	cross(a,b) - cross product
	normalize(a) - rescale to unit length
	faceforward(n, I, nr) - reorient a normal to point away from a surface
	reflect(I, N) - reflects vector I along axis N
	refract(I, N, eta) - refracts I according to Snell's law

BRANCHING
=========

use sparingly!!

if statements
	if (a < 0.5) {
	} else {
	}

comparisons
	component-wise comparison that returns a bvec
	lessThan(a,b), lessThanEqual(a,b)
	greaterThan(a,b), greaterThanEqual(a,b)
	equal(a,b)

boolean operations
	aggregate operations
	any(b), all(b), not(b)

LOOPS
=====

loops are supported but the number of loops must be statically determined and bounded
	for(int i=0; i < 100; ++i){
	}
	while(i < 10){
	i++;
	}

MATRICES
========

special datatypes for low dimensional (square matrices)
	mat2, mat3, mat4
	matrix constructors are in column mahjor order

	mat2 I = mat2(1.0, 0.0,
	              0.0, 1.0);
	// same thing
	mat2 I = mat2(1.0);

	can also be constructed by giving columns
	vec2 a = vec2(1,0);
	vec2 b = vec2(0,1);
	mat2 I = mat2(a,b);

	can access columns with square brackets so
	vec2 a = I[0]; // a = (1,0)

arithmetic
	component wise addition  m + w
	scalar multiplication 2 * m
	component-wise multiplication - matrixCompMult(m,w)
	matrix multiplication - m * w




INTRODUCTION TO FRAGMENT SHADERS
================================

a fragment is the color of some fraction of a pixel

entry point is procedure called main(), no arguments or return value
	output is RGBA color values in a builtin array gl_FragData[]
	n-th entry in the gl_FragData[n] array represents the color that will be written to the color attachment at position n. when rendering to the drawing buffer, which has only one color attachment can use gl_FragColor (gl_FragData[0])

	gl_FragCoord - special input to every gragment shader a vec4 which returns the coordinate of the fragment in device coordinates
	gl_FragCoord.xy - coordinate of the fragment in units relative to top-left of the buffer, y - row, x - column
	gl_FragCoord.z - depth value [0,1] 0 - closest, 1 - furthest away
	gl_FragCoord.w - reciprocal of the homogeneous part of the fragment's position in clip coordinates

THE DISCARD KEYWORD
===================

skip rendering of a fragment with the discard statement

UNIFORM VARIABLES AND TEXTURES
==============================

uniform variables are broadcast to all executions of a shader
	useful for small, frequently changing info
textures are 2d arrays of vectors, declared using sampler2D data type and can be accessed with built in function texture2D()
	vec4 texture2D(
	  in sampler2D texture, - sampler variable
	  in vec2 coordinate, - which data is read [0,1]
	  in float bias = 0.0 - changes filtering
	);
